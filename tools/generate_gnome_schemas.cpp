/*
 * Copyright (C) 2666680 Ontario Inc.
 *
 * SPDX-License-Identifier: MIT
 *
 */
#include <iostream>
#include <fstream>
#include <format>
#include <string>
#include <map>
#include <regex>

const std::map<std::string, std::string> elf_configs(
{
    {"elf_function_adder_config_schema", "schemas/elf/function_adder_config.schema.json"},
    {"elf_injector_config_schema", "schemas/elf/injector_config.schema.json"},
    {"elf_patcher_config_schema", "schemas/elf/patcher_config.schema.json"},
    {"elf_renamer_config_schema", "schemas/elf/renamer_config.schema.json"}
}
);

const std::map<std::string, std::map<std::string, std::string>> configs(
{
    {"elf_schemas", elf_configs}
}
);

const std::string convert_schema(const std::string base, const std::string type, const std::map<std::string, std::string> conf)
{
    std::string ret = "static std::map<std::string, std::string> " + type + "({\n";

    for (const auto& [var, file] : conf) {
        std::ifstream f(base + "/" + file);
        std::string line;
        std::string config_value = "";

        while (std::getline(f, line)) {
            config_value += line;
        }

        f.close();

        config_value = std::regex_replace(config_value, std::regex("\""), "\\\"");

        ret += "{\"" + var + "\", \"" + config_value + "\"},\n";
    }

    ret += "});\n";

    return ret;
}

const std::string get_includes()
{
    std::string ret = "";

    for (const auto& [type, schemas] : configs) {
        ret += "#include \"g_" + type + ".hpp\"";
    }

    return ret;
}

const std::string get_map_info()
{
    std::string ret = "{\n";

    for (const auto& [type, schemas] : configs) {
        ret += "\t{\"" + type + "\", " + type + "},\n";
    }

    ret += "}\n";

    return ret;
}

int main(int argc, char **argv)
{
    std::ofstream main_file;
    constexpr auto schemas_contents = R"""(
/*
 * Copyright (C) 2666680 Ontario Inc.
 *
 * SPDX-License-Identifier: MIT
 *
 * NOTE: AUTOGENERATED DO NOT MODIFY.
 *
 */
#ifndef g_schemas_hpp
#define g_schemas_hpp

#include <map>

{0}

static std::map<std::string, std::map<std::string, std::string>> schemas(
{1}
);

#endif
)""";

    if (argc != 3) {
        std::cout << argv[0] << " <source_directory> <binary_directory>\n";
        return EINVAL;
    }

    for (const auto& [type, schemas] : configs) {
        const std::string file_name =
            std::string(argv[2]) + "/g_" + type + ".hpp";
        constexpr auto file_contents = R"""(
/*
 * Copyright (C) 2666680 Ontario Inc.
 *
 * SPDX-License-Identifier: MIT
 *
 * NOTE: AUTOGENERATED DO NOT MODIFY.
 *
 */
#ifndef g_{0}_hpp
#define g_{0}_hpp

#include <map>

{1}

#endif
)""";
        std::ofstream file(file_name, std::ios::trunc);
        file << std::format(file_contents, type, convert_schema(std::string(argv[1]), type, schemas));
        file.close();
    }

    main_file.open(std::string(argv[2]) + "/g_schemas.hpp");
    main_file << std::format(schemas_contents, get_includes(), get_map_info());
    main_file.close();

    return 0;
}
